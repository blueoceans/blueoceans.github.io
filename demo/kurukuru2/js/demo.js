// Generated by CoffeeScript 1.6.3
"use strict";
var animate, camera, config, config_path, controls, init, objects, onWindowResize, projector, render, renderer, scene, targets, transform;

config_path = "./config.yaml";

config = void 0;

camera = void 0;

scene = void 0;

renderer = void 0;

controls = void 0;

objects = void 0;

projector = void 0;

targets = {
  table: [],
  sphere: [],
  helix: [],
  grid: []
};

init = function(config) {
  var index, object, phi, phi0, range, space, variability_x, variability_y, variability_z, vector, _, _i, _j, _k, _len, _len1, _ref, _ref1;
  space = config.object.space || 20;
  config.object.distance = config.item.length * (config.object.width + space) / (2 * Math.PI);
  config.camera._distance = config.object.distance + config.camera.distance;
  camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 1, 10000);
  camera.position.set(0, config.camera.height, config.camera._distance);
  scene = new THREE.Scene();
  range = config.object.distance;
  variability_x = config.object.variability.x;
  variability_y = config.object.variability.y;
  variability_z = config.object.variability.z;
  for (_i = 0, _len = objects.length; _i < _len; _i++) {
    object = objects[_i];
    vector = 2 * Math.PI * Math.random();
    object.position.x = Math.sin(vector) * range * variability_x;
    object.position.y = Math.sin(2 * Math.PI * Math.random()) * range * variability_y;
    object.position.z = Math.cos(vector) * range * variability_z;
    scene.add(object);
    object = new THREE.Object3D();
    targets.table.push(object);
  }
  if (!(targets.helix.length > 0)) {
    for (_ = _j = 0, _ref = objects.length; 0 <= _ref ? _j <= _ref : _j >= _ref; _ = 0 <= _ref ? ++_j : --_j) {
      object = new THREE.Object3D();
      targets.helix.push(object);
    }
  }
  phi0 = 2 * Math.PI / config.item.length;
  vector = new THREE.Vector3();
  _ref1 = targets.helix;
  for (index = _k = 0, _len1 = _ref1.length; _k < _len1; index = ++_k) {
    object = _ref1[index];
    phi = index * phi0;
    object.position.x = config.object.distance * Math.sin(phi);
    object.position.y = 0;
    object.position.z = config.object.distance * Math.cos(phi);
    vector.x = object.position.x * 2;
    vector.y = object.position.y;
    vector.z = object.position.z * 2;
    object.lookAt(vector);
  }
  renderer = new THREE.CSS3DRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.domElement.style.position = "absolute";
  document.getElementById("container").appendChild(renderer.domElement);
  controls = new THREE.TrackballControls(camera, renderer.domElement);
  controls.rotateSpeed = config.controls.rotateSpeed || 0.05;
  controls.minDistance = config.object.distance;
  controls.maxDistance = config.object.distance * 12;
  controls.addEventListener("change", render);
  transform(targets.helix, 5000);
  window.addEventListener("resize", onWindowResize, false);
};

transform = function(targets, duration) {
  var index, object, target, vector, _i, _len;
  TWEEN.removeAll();
  vector = new THREE.Vector3();
  for (index = _i = 0, _len = objects.length; _i < _len; index = ++_i) {
    object = objects[index];
    target = targets[index];
    vector.x = 0;
    vector.y = 0;
    vector.z = 10000;
    object.lookAt(vector);
    new TWEEN.Tween(object.position).to({
      x: target.position.x,
      y: target.position.y,
      z: target.position.z
    }, Math.random() * duration + duration).easing(TWEEN.Easing.Exponential.InOut).start();
    new TWEEN.Tween(object.rotation).to({
      x: target.rotation.x,
      y: target.rotation.y,
      z: target.rotation.z
    }, Math.random() * duration + duration).easing(TWEEN.Easing.Exponential.InOut).start();
  }
  new TWEEN.Tween(this).to({}, duration * 2).onUpdate(render).onComplete(function() {}).start();
};

onWindowResize = function() {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
  render();
};

animate = function() {
  requestAnimationFrame(animate);
  TWEEN.update();
  controls.update();
};

render = function() {
  renderer.render(scene, camera);
};

angular.module("app", ["app.controllers", "app.directives"]).config([
  "$interpolateProvider", function($interpolateProvider) {
    $interpolateProvider.startSymbol("[[");
    $interpolateProvider.endSymbol("]]");
  }
]);

/* Controllers*/


angular.module("app.controllers", []).controller("Ctrl", [
  "$scope", "$location", "$log", "$http", "$timeout", "$window", function($scope, $location, $log, $http, $timeout, $window) {
    var fade_reflect, hide_reflect, img_loaded, omega, rotate_to, rotation;
    img_loaded = 0;
    $http.get(config_path).success(function(data, _status, headers, _config) {
      var mask_img;
      $scope.c = config = jsyaml.load(data);
      $scope.rotate = config.camera.rotate;
      if ($scope.$$phase == null) {
        $scope.$apply();
      }
      mask_img = angular.element("#mask-img")[0];
      mask_img.onload = function() {
        var height, width;
        fade_reflect();
        width = $scope.c.object.width;
        height = $scope.c.object.reflect || $scope.c.object.height;
        angular.forEach(angular.element(".element-canvas"), function(canvas) {
          var img;
          canvas.width = width;
          canvas.height = height;
          canvas.style.width = "" + width + "px";
          canvas.style.height = "" + height + "px";
          img = canvas.parentNode.previousElementSibling;
          img.onload = function() {
            var context;
            context = canvas.getContext("2d");
            context.clearRect(0, 0, img.width, img.height);
            context.drawImage(img, 0, 0, img.width, img.height);
            context.globalCompositeOperation = "xor";
            context.drawImage(mask_img, 0, 0, img.width, img.height);
            img_loaded += 1;
            if (img_loaded >= $scope.c.item.length) {
              addReflections();
            }
          };
        });
        hide_reflect();
      };
      $timeout(function() {
        var element;
        objects = (function() {
          var _i, _len, _ref, _results;
          _ref = angular.element(".element");
          _results = [];
          for (_i = 0, _len = _ref.length; _i < _len; _i++) {
            element = _ref[_i];
            _results.push(new THREE.CSS3DObject(element));
          }
          return _results;
        })();
        $scope.reset();
        animate();
        rotation();
      }, 200);
    });
    hide_reflect = function() {
      var reflect;
      reflect = angular.element(".element-canvas canvas:not(.reflected)");
      if (reflect.length > 0) {
        $(reflect).addClass("ng-hide");
      } else {
        $timeout(fade_reflect, 200);
      }
    };
    fade_reflect = function() {
      var canvas, reflect, _i, _len;
      reflect = angular.element(".element-canvas canvas:not(.reflected)");
      if (reflect.length > 0) {
        for (_i = 0, _len = reflect.length; _i < _len; _i++) {
          canvas = reflect[_i];
          canvas.style.opacity = 0;
          new TWEEN.Tween(canvas.style).to({
            opacity: 1
          }, 2000).delay(3000).easing(TWEEN.Easing.Quadratic.In).start();
        }
        $(reflect).removeClass("ng-hide");
      } else {
        $timeout(fade_reflect, 200);
      }
    };
    omega = 0;
    $scope.reset = function() {
      omega = 0;
      $scope.rotate = config.camera.rotate;
      hide_reflect();
      init($scope.c);
      fade_reflect();
      renderer.domElement.addEventListener("click", (function(evt) {
        var current, element, length, next, url, _ref, _ref1;
        element = evt.toElement;
        if ((_ref = element.className) !== "element-img" && _ref !== "element-canvas") {
          return;
        }
        next = Number(element.getAttribute("data-nth"));
        url = (_ref1 = $scope.c.item[next]) != null ? _ref1[1] : void 0;
        length = $scope.c.item.length;
        current = Math.floor(length * omega / (2 * Math.PI));
        if (Math.abs(next - current) > length / 2) {
          next += length * ((next - current) < 0 ? 1 : -1);
        }
        rotate_to(next);
        if (url) {
          $timeout(function() {
            $window.open(url);
          }, $scope.c.efect.time + 100);
        }
      }), false);
    };
    $scope.zoom = function(magnification) {
      new TWEEN.Tween($scope.c.camera).to({
        _distance: $scope.c.camera._distance * magnification
      }, $scope.c.efect.time).easing(TWEEN.Easing.Linear.None).onUpdate(function() {
        camera.position.x = Math.sin(omega) * $scope.c.camera._distance;
        camera.position.z = Math.cos(omega) * $scope.c.camera._distance;
      }).onComplete(function() {
        if (!$scope.mouseup) {
          $scope.zoom(magnification);
        }
      }).start();
    };
    rotation = function() {
      camera.lookAt(scene.position);
      $timeout(rotation, 40);
    };
    $scope.rotate_next = function(direction) {
      var current, left, length, next;
      left = $scope.rotate ? 0 : -1;
      length = $scope.c.item.length;
      current = length * omega / (2 * Math.PI);
      next = Math.round(current) + (direction === "left" ? left : 1);
      rotate_to(next, direction);
    };
    rotate_to = function(next, direction) {
      var current, height, length;
      height = $scope.c.object.height || 200;
      if (camera.position.y % (height / 2) !== 0) {
        controls.reset();
      }
      if ($scope.rotate) {
        $scope.rotate = false;
      }
      length = $scope.c.item.length;
      current = Math.floor(length * omega / (2 * Math.PI));
      if (Math.abs(next - current) > length / 2) {
        next += length * ((next - current) < 0 ? 1 : -1);
      }
      new TWEEN.Tween({
        omega: omega
      }).to({
        omega: 2 * Math.PI / length * next
      }, $scope.c.efect.time).easing(TWEEN.Easing.Linear.None).onUpdate(function() {
        omega = this.omega;
        camera.position.x = Math.sin(omega) * $scope.c.camera._distance;
        camera.position.z = Math.cos(omega) * $scope.c.camera._distance;
      }).onComplete(function() {
        if (!$scope.mouseup) {
          $timeout(function() {
            $scope.rotate_next(direction);
          }, 40);
        }
      }).start();
    };
    $scope.up = function(range) {
      if (!range) {
        range = ($scope.c.object.height || 200) / 2;
      }
      new TWEEN.Tween(camera.position).to({
        y: camera.position.y + range
      }, $scope.c.efect.time).easing(TWEEN.Easing.Linear.None).onComplete(function() {
        if (!$scope.mouseup) {
          $scope.up(range);
        }
      }).start();
    };
    $scope.down = function() {
      $scope.up(($scope.c.object.height || 200) / -2);
    };
  }
]).controller("jmpress", [
  "$scope", "$location", "$log", "$http", "$timeout", "$window", function($scope, $location, $log, $http, $timeout, $window) {
    return $http.get(config_path).success(function(data, _status, headers, _config) {
      $scope.c = config = jsyaml.load(data);
      $scope.rotate = config.camera.rotate;
      if ($scope.$$phase == null) {
        $scope.$apply();
      }
    });
  }
]);

/* Directives*/


angular.module("app.directives", []).directive("jmpress", function() {
  return function($scope, elm, attrs) {
    jmpress_init();
  };
});

/* Init*/


angular.element(document).ready(function() {
  return angular.bootstrap(document, ["app"]);
});
